<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    * {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    body {
      background-color: rgb(109, 204, 236);
      touch-action: none;
    }

    svg {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .country {
      fill: #FFFFE0;
      stroke: #000000;
      stroke-width: 0.07;
      shape-rendering: optimizeSpeed;
      cursor: pointer;
      pointer-events: all;
    }

    .country:hover {
      fill: #b5ffb5;
    }

    #countries {
      will-change: transform;
      transform-origin: 0 0;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      /* Force rasterization - scale the bitmap, don't re-render SVG */
      isolation: isolate;
      contain: layout style paint;
    }

    /* Hardware acceleration hint */
    svg {
      transform: translateZ(0);
      shape-rendering: optimizeSpeed;
      /* Treat SVG as bitmap during transforms */
      image-rendering: optimizeSpeed;
      image-rendering: -webkit-optimize-contrast;
    }

    /* Optimize rendering */
    * {
      -webkit-font-smoothing: antialiased;
      -webkit-tap-highlight-color: transparent;
    }

    /* Force layer compositing */
    body, html {
      transform: translate3d(0, 0, 0);
    }

    .ocean {
      fill: rgb(109, 204, 236);
    }

    #labels {
      will-change: transform;
      transform-origin: 0 0;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      pointer-events: none; /* Labels don't need interaction */
    }

    .country-label {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      /* font-size and stroke-width will be set dynamically via JavaScript */
      font-weight: 700;
      fill: rgba(0, 0, 0, 0.85);
      stroke: rgba(255, 255, 255, 0.9);
      paint-order: stroke fill;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <svg id="map" preserveAspectRatio="xMidYMin meet" viewBox="0 0 1000 482">
    <rect class="ocean" x="0" y="0" width="1000" height="482" />
    <g id="countries"></g>
    <g id="labels"></g>
  </svg>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
//# sourceURL=map-viewer.js
    (function() {
      // Shared constants for label styling
      const BASE_FONT_SIZE = 8; // Base font size in px
      const BASE_STROKE_WIDTH = 1.5; // Base stroke width in px

      const svg = d3.select('#map');
      const countriesGroup = d3.select('#countries');
      const labelsGroup = d3.select('#labels');

      // SVG data is embedded directly (injected from React Native)
      const svgText = `{{SVG_DATA}}`;

      // Countries data (injected from React Native)
      const countriesJson = `{{COUNTRIES_DATA}}`;

      // Create country code to name lookup map
      const countryNameMap = {};
      try {
        const countries = JSON.parse(countriesJson);
        countries.forEach(country => {
          countryNameMap[country.code] = country.name;
        });
        console.log('Loaded country names for', Object.keys(countryNameMap).length, 'countries');
      } catch (error) {
        console.error('Error parsing countries data:', error);
      }

      // Store zoom object globally within this scope for zoomToCountry function
      let zoomBehavior;

      // Store country data with sizes for dynamic label visibility
      const countryData = [];

      // Function to add country ID labels at centroid of each country
      function addCountryLabels() {
        // Get all country paths
        const countryPaths = countriesGroup.selectAll('.country');

        countryPaths.each(function() {
          const path = this;
          const countryCode = path.getAttribute('id');

          // Skip if no ID
          if (!countryCode) return;

          // Calculate centroid using bounding box
          const bbox = path.getBBox();
          const centerX = bbox.x + bbox.width / 2;
          const centerY = bbox.y + bbox.height / 2;

          // Calculate country size (area of bounding box as proxy)
          const size = bbox.width * bbox.height;

          // Get country name from lookup map, fallback to code if not found
          const countryName = countryNameMap[countryCode] || countryCode;

          // Store country data
          countryData.push({
            id: countryCode,
            name: countryName,
            x: centerX,
            y: centerY,
            size: size
          });
        });

        // Sort countries by size (largest first)
        countryData.sort((a, b) => b.size - a.size);

        // Add labels for all countries
        countryData.forEach((country, index) => {
          labelsGroup.append('text')
            .attr('class', 'country-label')
            .attr('x', country.x)
            .attr('y', country.y)
            .attr('data-size-rank', index) // Store rank for visibility control
            .attr('data-size', country.size)
            .text(country.name) // Use country name instead of code
            .style('display', 'none') // Initially hidden, will be shown based on zoom
            .style('font-size', `${BASE_FONT_SIZE}px`) // Set initial font size
            .style('stroke-width', `${BASE_STROKE_WIDTH}px`); // Set initial stroke width
        });

        console.log('Added labels for', countryData.length, 'countries');
      }

      // Function to update label visibility based on zoom level and viewport culling
      function updateLabelVisibility(scale, initialScale, translateX, translateY) {
        // Calculate zoom factor relative to initial scale
        const zoomFactor = scale / initialScale;

        // Define visibility thresholds
        // At 1x zoom (initial): show top 10% (largest countries)
        // At 2x zoom: show top 25%
        // At 4x zoom: show top 50%
        // At 8x zoom: show top 75%
        // At 16x+ zoom: show all countries

        let visiblePercentage;
        if (zoomFactor < 1.5) {
          visiblePercentage = 0.10; // 10%
        } else if (zoomFactor < 3) {
          visiblePercentage = 0.25; // 25%
        } else if (zoomFactor < 6) {
          visiblePercentage = 0.50; // 50%
        } else if (zoomFactor < 12) {
          visiblePercentage = 0.75; // 75%
        } else {
          visiblePercentage = 1.0; // 100%
        }

        const visibleCount = Math.ceil(countryData.length * visiblePercentage);

        // Viewport bounds in screen coordinates
        // const viewportWidth = window.innerWidth;
        // const viewportHeight = window.innerHeight;
        const viewportWidth = 1000;
        const viewportHeight =1000 * window.innerHeight / window.innerWidth;

        // Add padding to viewport bounds (show labels slightly outside screen)
        const padding = 50; // pixels
        const minX = -padding;
        const minY = -padding;
        const maxX = viewportWidth + padding;
        const maxY = viewportHeight + padding;

        // Update visibility of all labels
        labelsGroup.selectAll('.country-label').each(function() {
          const label = this;
          const rank = parseInt(label.getAttribute('data-size-rank'));

          // First check: is this country large enough to show at this zoom level?
          if (rank >= visibleCount) {
            label.style.display = 'none';
            return;
          }

          // Second check: is the label within the viewport?
          // Transform label position from map coordinates to screen coordinates
          const mapX = parseFloat(label.getAttribute('x'));
          const mapY = parseFloat(label.getAttribute('y'));

          const screenX = mapX * scale + translateX;
          const screenY = mapY * scale + translateY;

          // Check if label is within viewport bounds (with padding)
          const isInViewport = screenX >= minX && screenX <= maxX &&
                               screenY >= minY && screenY <= maxY;

          if (isInViewport) {
            label.style.display = 'block';
          } else {
            label.style.display = 'none';
          }
        });
      }

      // Function to zoom to a specific country
      function zoomToCountry(pathElement) {
        // Get the bounding box of the country path
        const bbox = pathElement.getBBox();

        console.log('Country bbox:', {
          x: bbox.x,
          y: bbox.y,
          width: bbox.width,
          height: bbox.height
        });

        // Viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Calculate scale to fit the country in viewport with some padding
        const padding = 0; // pixels of padding around the country
        const scaleX = (1000 - padding * 2) / bbox.width;
        const scaleY = (viewportHeight / viewportWidth * 1000 - padding * 2) / bbox.height;
        const scale = Math.min(scaleX, scaleY); // Use smaller scale to ensure fit

        // Calculate the center of the bounding box in SVG coordinates
        const centerX = bbox.x + bbox.width / 2;
        const centerY = bbox.y + bbox.height / 2;

        // Calculate translation to center the country in viewport
        const translateX = 1000 / 2 - centerX * scale;
        const translateY = (viewportHeight / viewportWidth * 1000) / 2 - centerY * scale;




       

        // Create the transform
        const transform = d3.zoomIdentity
          .translate(translateX, translateY)
          .scale(scale);

        // Animate to the new transform
        svg.transition()
          .duration(1000) // 750ms animation
          .call(zoomBehavior.transform, transform);
      }


      try {
        // Parse SVG and extract paths
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
        const paths = svgDoc.querySelectorAll('path');

        console.log('Parsing SVG, found paths:', paths.length);

        // Add paths to D3 selection with click handlers
        paths.forEach(path => {
          const countryPath = countriesGroup.append('path')
            .attr('class', 'country')
            .attr('d', path.getAttribute('d'))
            .attr('id', path.getAttribute('id') || '');

          // Add click handler to zoom to country
          countryPath.on('click', function(event) {
            event.stopPropagation();
            const countryId = this.getAttribute('id');
            // console.log('Country clicked:', countryId);

            // Notify React Native
            window.ReactNativeWebView?.postMessage(JSON.stringify({
              type: 'countryClick',
              countryId: countryId
            }));

            // Zoom to the country
            zoomToCountry(this);
          });
        });

        console.log(`Loaded ${paths.length} country paths`);

        // Add country labels after all paths are loaded
        addCountryLabels();

        setupZoom();
      } catch (error) {
        console.error('Error parsing SVG:', error);
      }

      function setupZoom() {
        // Use CSS transform instead of SVG transform for better performance
        const countriesNode = countriesGroup.node();
        const labelsNode = labelsGroup.node();
        const svgElement = svg.node();

        // Map dimensions in SVG coordinates
        const MAP_WIDTH = 1000;
        const MAP_HEIGHT = 482;

        // Viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Initial scale from React Native (may not be 1.0)
        const initialScale = {{INITIAL_SCALE}};

        // Use requestAnimationFrame for smoother updates
        let ticking = false;
        let pendingTransform = null;

        // Momentum/flick scrolling variables
        let lastTransform = null;
        let lastTimestamp = 0;
        let velocityX = 0;
        let velocityY = 0;
        let momentumAnimation = null;
        let isAnimatingMomentum = false; // Flag to prevent event handlers from interfering
        let isPinchZooming = false; // Flag to detect pinch zoom gestures

        // Custom constrain function to limit panning within map boundaries
        function constrainTransform(transform) {
          const scale = transform.k;

          // // Calculate the scaled map dimensions in screen pixels
          const scaledWidth = MAP_WIDTH * scale;
          const scaledHeight = MAP_HEIGHT * scale;

          // const scaledWidth = viewportWidth * scale;
          // const scaledHeight = scaledWidth * MAP_HEIGHT / MAP_WIDTH;

          // Calculate min/max translation bounds
          // The map edges should not go beyond the viewport edges

          // X bounds
          const maxX = 0; // Left edge of map can't go right of viewport left
          const minX = 1000 - scaledWidth; // Right edge of map can't go left of viewport right

          // Y bounds
          const maxY = 0; // Top edge of map can't go below viewport top
          const minY = 1000 * (viewportHeight / viewportWidth) - scaledHeight; // Bottom edge of map can't go above viewport bottom

          // Clamp the translation values
          let x = transform.x;
          let y = transform.y;

          // Only constrain if map is larger than viewport, otherwise allow centering
          if (scaledWidth > viewportWidth) {
            x = Math.max(minX, Math.min(maxX, x));
          } else {
            // Center horizontally if map is smaller than viewport
            x = (viewportWidth - scaledWidth) / 2;
          }

          if (scaledHeight > viewportHeight) {
            y = Math.max(minY, Math.min(maxY, y));
          } else {
            // Center vertically if map is smaller than viewport
            y = (viewportHeight - scaledHeight) / 2;
          }

          const debugInfo = {
            scale,
            scaledDims: [Math.round(scaledWidth), Math.round(scaledHeight)],
            viewport: [viewportWidth, viewportHeight],
            bounds: { x: [Math.round(minX), Math.round(maxX)], y: [Math.round(minY), Math.round(maxY)] },
            before: [Math.round(transform.x), Math.round(transform.y)],
            after: [Math.round(x), Math.round(y)]
          };
          console.log('Constraint:', JSON.stringify(debugInfo));

          // Send debug info to React Native (will appear once per pan gesture)
          if (window.ReactNativeWebView && Math.random() < 0.1) { // Only 10% of the time to avoid spam
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'debug',
              data: debugInfo
            }));
          }

          return d3.zoomIdentity.translate(x, y).scale(scale);
        }

        // Momentum animation function
        function animateMomentum() {
          if (Math.abs(velocityX) < 0.5 && Math.abs(velocityY) < 0.5) {
            // Velocity too small, stop animation
            velocityX = 0;
            velocityY = 0;
            momentumAnimation = null;
            isAnimatingMomentum = false;
            return;
          }

          // Get current transform
          const currentTransform = d3.zoomTransform(svgElement);

          // Apply velocity to position
          const newX = currentTransform.x + velocityX;
          const newY = currentTransform.y + velocityY;

          // Create new transform with constraints
          let newTransform = d3.zoomIdentity
            .translate(newX, newY)
            .scale(currentTransform.k);

          // Apply constraints
          newTransform = constrainTransform(newTransform);

          // Check if we hit a boundary (constrained position != desired position)
          const hitBoundaryX = Math.abs(newTransform.x - newX) > 0.1;
          const hitBoundaryY = Math.abs(newTransform.y - newY) > 0.1;

          // Stop velocity on the axis that hit boundary
          if (hitBoundaryX) velocityX = 0;
          if (hitBoundaryY) velocityY = 0;

          // Set flag to prevent event handlers from resetting velocity
          isAnimatingMomentum = true;

          // Apply the transform
          svg.call(zoomBehavior.transform, newTransform);

          // Apply friction (deceleration)
          velocityX *= 0.95;
          velocityY *= 0.95;

          // Continue animation
          momentumAnimation = requestAnimationFrame(animateMomentum);
        }

        // Create zoom behavior and store it globally
        zoomBehavior = d3.zoom()
          .scaleExtent([initialScale, initialScale * 20]) // Start from initialScale, not 1.0
          .constrain(constrainTransform)
          .on('start', (event) => {
            console.log('Zoom start:', event.sourceEvent?.type, 'isAnimatingMomentum:', isAnimatingMomentum);

            // Check if this is a real user gesture (has sourceEvent)
            const isUserGesture = event.sourceEvent != null;

            // Always cancel momentum on real user gestures (touch/mouse)
            if (isUserGesture && momentumAnimation) {
              console.log('Canceling momentum due to user gesture');
              cancelAnimationFrame(momentumAnimation);
              momentumAnimation = null;
              isAnimatingMomentum = false;
              velocityX = 0;
              velocityY = 0;
            }

            // Reset pinch zoom flag on new gesture
            isPinchZooming = false;

            // Only reset tracking for real user gestures (not programmatic transforms)
            if (isUserGesture || !isAnimatingMomentum) {
              lastTransform = event.transform;
              lastTimestamp = Date.now();
            }
          })
          .on('zoom', (event) => {
            // Skip velocity tracking during momentum animation
            if (!isAnimatingMomentum) {
              // Track velocity for momentum
              const now = Date.now();
              const dt = now - lastTimestamp;

              if (dt > 0 && lastTransform && event.sourceEvent) {
                // Detect if scale is changing (pinch zoom)
                const scaleChanged = Math.abs(event.transform.k - lastTransform.k) > 0.01;

                if (scaleChanged) {
                  // This is a pinch zoom gesture, not a pan
                  isPinchZooming = true;
                  velocityX = 0;
                  velocityY = 0;
                } else if (!isPinchZooming && (event.sourceEvent.type === 'touchmove' || event.sourceEvent.type === 'mousemove')) {
                  // Only track velocity during pure pan (no scale change)
                  const dx = event.transform.x - lastTransform.x;
                  const dy = event.transform.y - lastTransform.y;

                  // Calculate velocity in pixels per millisecond
                  velocityX = dx / dt * 16; // Scale to ~60fps
                  velocityY = dy / dt * 16;
                }
              }

              lastTransform = event.transform;
              lastTimestamp = now;
            }

            pendingTransform = event.transform;

            //this piece of code is used to batch all the x,y,scale changes into one frame, -> improve performance
            if (!ticking) {
              requestAnimationFrame(() => {
                if (pendingTransform) {
                  // Apply transform using CSS transform (GPU accelerated)
                  const t = pendingTransform;
                  const transformString = `translate3d(${t.x}px, ${t.y}px, 0) scale(${t.k})`;
                  countriesNode.style.transform = transformString;
                  labelsNode.style.transform = transformString;

                  // Adjust font size to counter the scale, keeping text size constant
                  const adjustedFontSize = BASE_FONT_SIZE / t.k * initialScale;
                  const adjustedStrokeSize = BASE_STROKE_WIDTH / t.k * initialScale;

                  labelsGroup.selectAll('.country-label').each(function() {
                    this.style.fontSize = `${adjustedFontSize}px`;
                    this.style.strokeWidth = `${adjustedStrokeSize}px`;
                  });

                  // Update label visibility based on zoom level and viewport
                  updateLabelVisibility(t.k, initialScale, t.x, t.y);

                  pendingTransform = null;
                }
                ticking = false;
              });
              ticking = true;
            }
          })
          .on('end', (event) => {
            // Start momentum animation if velocity is significant
            const speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);

            console.log('Zoom end:', {
              eventType: event.sourceEvent?.type,
              velocity: [velocityX.toFixed(2), velocityY.toFixed(2)],
              speed: speed.toFixed(2),
              isPinchZooming
            });

            // Only apply momentum if:
            // 1. Speed is significant
            // 2. This is a touch/mouse end event
            // 3. This was NOT a pinch zoom gesture
            if (speed > 1 && event.sourceEvent && !isPinchZooming) {
              const eventType = event.sourceEvent.type;
              if (eventType === 'touchend' || eventType === 'mouseup') {
                console.log('✅ Starting momentum animation');
                isAnimatingMomentum = false; // Will be set to true in animateMomentum
                animateMomentum();
              } else {
                console.log('❌ Wrong event type for momentum:', eventType);
              }
            } else {
              if (isPinchZooming) {
                console.log('❌ Was pinch zooming, no momentum');
              } else {
                console.log('❌ Speed too low or no sourceEvent');
              }
            }

            // Send transform data to React Native when zoom ends
            window.ReactNativeWebView?.postMessage(JSON.stringify({
              type: 'transform',
              scale: event.transform.k,
              translateX: event.transform.x,
              translateY: event.transform.y
            }));
          });

        svg.call(zoomBehavior);

        // Set initial zoom to fit screen
        svg.call(zoomBehavior.transform, d3.zoomIdentity.scale(initialScale));

        // Set initial label visibility (show only largest countries at initial zoom)
        updateLabelVisibility(initialScale, initialScale, 0, 0);

        // console.log('Zoom setup complete');
        // console.log('Initial scale:', initialScale);
        // console.log('Viewport:', viewportWidth, 'x', viewportHeight);
        // console.log('Map bounds:', MAP_WIDTH, 'x', MAP_HEIGHT);
        // console.log('Initial scaled size:', MAP_WIDTH * initialScale, 'x', MAP_HEIGHT * initialScale);
      }

      // Handle messages from React Native
      document.addEventListener('message', function(event) {
        const data = JSON.parse(event.data);
        if (data.type === 'zoomToCountry') {
          // Implement zoom to country functionality if needed
        }
      });
    })();
  </script>
</body>
</html>
