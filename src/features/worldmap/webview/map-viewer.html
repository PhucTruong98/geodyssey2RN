<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    * {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    body {
      background-color: rgb(109, 204, 236);
      touch-action: none;
    }

    svg {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .country {
      fill: #FFFFE0;
      stroke: #000000;
      stroke-width: 0.07;
      shape-rendering: optimizeSpeed;
      cursor: pointer;
      pointer-events: all;
    }

    .country:hover {
      fill: #b5ffb5;
    }

    #countries {
      will-change: transform;
      transform-origin: 0 0;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      /* Force rasterization - scale the bitmap, don't re-render SVG */
      isolation: isolate;
      contain: layout style paint;
    }

    /* Hardware acceleration hint */
    svg {
      transform: translateZ(0);
      shape-rendering: optimizeSpeed;
      /* Treat SVG as bitmap during transforms */
      image-rendering: optimizeSpeed;
      image-rendering: -webkit-optimize-contrast;
    }

    /* Optimize rendering */
    * {
      -webkit-font-smoothing: antialiased;
      -webkit-tap-highlight-color: transparent;
    }

    /* Force layer compositing */
    body, html {
      transform: translate3d(0, 0, 0);
    }

    .ocean {
      fill: rgb(109, 204, 236);
    }
  </style>
</head>
<body>
  <svg id="map" preserveAspectRatio="xMidYMin meet" viewBox="0 0 1000 482">
    <rect class="ocean" x="0" y="0" width="1000" height="482" />
    <g id="countries"></g>
  </svg>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
//# sourceURL=map-viewer.js
    (function() {
      const svg = d3.select('#map');
      const countriesGroup = d3.select('#countries');

      // SVG data is embedded directly (injected from React Native)
      const svgText = `{{SVG_DATA}}`;


      // Store zoom object globally within this scope for zoomToCountry function
      let zoomBehavior;

      // Function to zoom to a specific country
      function zoomToCountry(pathElement) {
        // Get the bounding box of the country path
        const bbox = pathElement.getBBox();

        console.log('Country bbox:', {
          x: bbox.x,
          y: bbox.y,
          width: bbox.width,
          height: bbox.height
        });

        // Viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Calculate scale to fit the country in viewport with some padding
        const padding = 0; // pixels of padding around the country
        const scaleX = (1000 - padding * 2) / bbox.width;
        const scaleY = (viewportHeight / viewportWidth * 1000 - padding * 2) / bbox.height;
        const scale = Math.min(scaleX, scaleY); // Use smaller scale to ensure fit

        // Calculate the center of the bounding box in SVG coordinates
        const centerX = bbox.x + bbox.width / 2;
        const centerY = bbox.y + bbox.height / 2;

        // Calculate translation to center the country in viewport
        const translateX = 1000 / 2 - centerX * scale;
        const translateY = (viewportHeight / viewportWidth * 1000) / 2 - centerY * scale;




       

        // Create the transform
        const transform = d3.zoomIdentity
          .translate(translateX, translateY)
          .scale(scale);

        // Animate to the new transform
        svg.transition()
          .duration(1000) // 750ms animation
          .call(zoomBehavior.transform, transform);
      }


      try {
        // Parse SVG and extract paths
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
        const paths = svgDoc.querySelectorAll('path');

        console.log('Parsing SVG, found paths:', paths.length);

        // Add paths to D3 selection with click handlers
        paths.forEach(path => {
          const countryPath = countriesGroup.append('path')
            .attr('class', 'country')
            .attr('d', path.getAttribute('d'))
            .attr('id', path.getAttribute('id') || '');

          // Add click handler to zoom to country
          countryPath.on('click', function(event) {
            event.stopPropagation();
            const countryId = this.getAttribute('id');
            // console.log('Country clicked:', countryId);

            // Notify React Native
            window.ReactNativeWebView?.postMessage(JSON.stringify({
              type: 'countryClick',
              countryId: countryId
            }));

            // Zoom to the country
            zoomToCountry(this);
          });
        });

        console.log(`Loaded ${paths.length} country paths`);
        setupZoom();
      } catch (error) {
        console.error('Error parsing SVG:', error);
      }

      function setupZoom() {
        // Use CSS transform instead of SVG transform for better performance
        const countriesNode = countriesGroup.node();
        const svgElement = svg.node();

        // Map dimensions in SVG coordinates
        const MAP_WIDTH = 1000;
        const MAP_HEIGHT = 482;

        // Viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Initial scale from React Native (may not be 1.0)
        const initialScale = {{INITIAL_SCALE}};

        // Use requestAnimationFrame for smoother updates
        let ticking = false;
        let pendingTransform = null;

        // Momentum/flick scrolling variables
        let lastTransform = null;
        let lastTimestamp = 0;
        let velocityX = 0;
        let velocityY = 0;
        let momentumAnimation = null;
        let isAnimatingMomentum = false; // Flag to prevent event handlers from interfering
        let isPinchZooming = false; // Flag to detect pinch zoom gestures

        // Custom constrain function to limit panning within map boundaries
        function constrainTransform(transform) {
          const scale = transform.k;

          // // Calculate the scaled map dimensions in screen pixels
          const scaledWidth = MAP_WIDTH * scale;
          const scaledHeight = MAP_HEIGHT * scale;

          // const scaledWidth = viewportWidth * scale;
          // const scaledHeight = scaledWidth * MAP_HEIGHT / MAP_WIDTH;

          // Calculate min/max translation bounds
          // The map edges should not go beyond the viewport edges

          // X bounds
          const maxX = 0; // Left edge of map can't go right of viewport left
          const minX = 1000 - scaledWidth; // Right edge of map can't go left of viewport right

          // Y bounds
          const maxY = 0; // Top edge of map can't go below viewport top
          const minY = 1000 * (viewportHeight / viewportWidth) - scaledHeight; // Bottom edge of map can't go above viewport bottom

          // Clamp the translation values
          let x = transform.x;
          let y = transform.y;

          // Only constrain if map is larger than viewport, otherwise allow centering
          if (scaledWidth > viewportWidth) {
            x = Math.max(minX, Math.min(maxX, x));
          } else {
            // Center horizontally if map is smaller than viewport
            x = (viewportWidth - scaledWidth) / 2;
          }

          if (scaledHeight > viewportHeight) {
            y = Math.max(minY, Math.min(maxY, y));
          } else {
            // Center vertically if map is smaller than viewport
            y = (viewportHeight - scaledHeight) / 2;
          }

          const debugInfo = {
            scale,
            scaledDims: [Math.round(scaledWidth), Math.round(scaledHeight)],
            viewport: [viewportWidth, viewportHeight],
            bounds: { x: [Math.round(minX), Math.round(maxX)], y: [Math.round(minY), Math.round(maxY)] },
            before: [Math.round(transform.x), Math.round(transform.y)],
            after: [Math.round(x), Math.round(y)]
          };
          console.log('Constraint:', JSON.stringify(debugInfo));

          // Send debug info to React Native (will appear once per pan gesture)
          if (window.ReactNativeWebView && Math.random() < 0.1) { // Only 10% of the time to avoid spam
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'debug',
              data: debugInfo
            }));
          }

          return d3.zoomIdentity.translate(x, y).scale(scale);
        }

        // Momentum animation function
        function animateMomentum() {
          if (Math.abs(velocityX) < 0.5 && Math.abs(velocityY) < 0.5) {
            // Velocity too small, stop animation
            velocityX = 0;
            velocityY = 0;
            momentumAnimation = null;
            isAnimatingMomentum = false;
            return;
          }

          // Get current transform
          const currentTransform = d3.zoomTransform(svgElement);

          // Apply velocity to position
          const newX = currentTransform.x + velocityX;
          const newY = currentTransform.y + velocityY;

          // Create new transform with constraints
          let newTransform = d3.zoomIdentity
            .translate(newX, newY)
            .scale(currentTransform.k);

          // Apply constraints
          newTransform = constrainTransform(newTransform);

          // Check if we hit a boundary (constrained position != desired position)
          const hitBoundaryX = Math.abs(newTransform.x - newX) > 0.1;
          const hitBoundaryY = Math.abs(newTransform.y - newY) > 0.1;

          // Stop velocity on the axis that hit boundary
          if (hitBoundaryX) velocityX = 0;
          if (hitBoundaryY) velocityY = 0;

          // Set flag to prevent event handlers from resetting velocity
          isAnimatingMomentum = true;

          // Apply the transform
          svg.call(zoomBehavior.transform, newTransform);

          // Apply friction (deceleration)
          velocityX *= 0.95;
          velocityY *= 0.95;

          // Continue animation
          momentumAnimation = requestAnimationFrame(animateMomentum);
        }

        // Create zoom behavior and store it globally
        zoomBehavior = d3.zoom()
          .scaleExtent([initialScale, initialScale * 20]) // Start from initialScale, not 1.0
          .constrain(constrainTransform)
          .on('start', (event) => {
            console.log('Zoom start:', event.sourceEvent?.type, 'isAnimatingMomentum:', isAnimatingMomentum);

            // Check if this is a real user gesture (has sourceEvent)
            const isUserGesture = event.sourceEvent != null;

            // Always cancel momentum on real user gestures (touch/mouse)
            if (isUserGesture && momentumAnimation) {
              console.log('Canceling momentum due to user gesture');
              cancelAnimationFrame(momentumAnimation);
              momentumAnimation = null;
              isAnimatingMomentum = false;
              velocityX = 0;
              velocityY = 0;
            }

            // Reset pinch zoom flag on new gesture
            isPinchZooming = false;

            // Only reset tracking for real user gestures (not programmatic transforms)
            if (isUserGesture || !isAnimatingMomentum) {
              lastTransform = event.transform;
              lastTimestamp = Date.now();
            }
          })
          .on('zoom', (event) => {
            // Skip velocity tracking during momentum animation
            if (!isAnimatingMomentum) {
              // Track velocity for momentum
              const now = Date.now();
              const dt = now - lastTimestamp;

              if (dt > 0 && lastTransform && event.sourceEvent) {
                // Detect if scale is changing (pinch zoom)
                const scaleChanged = Math.abs(event.transform.k - lastTransform.k) > 0.01;

                if (scaleChanged) {
                  // This is a pinch zoom gesture, not a pan
                  isPinchZooming = true;
                  velocityX = 0;
                  velocityY = 0;
                } else if (!isPinchZooming && (event.sourceEvent.type === 'touchmove' || event.sourceEvent.type === 'mousemove')) {
                  // Only track velocity during pure pan (no scale change)
                  const dx = event.transform.x - lastTransform.x;
                  const dy = event.transform.y - lastTransform.y;

                  // Calculate velocity in pixels per millisecond
                  velocityX = dx / dt * 16; // Scale to ~60fps
                  velocityY = dy / dt * 16;
                }
              }

              lastTransform = event.transform;
              lastTimestamp = now;
            }

            pendingTransform = event.transform;

            //this piece of code is used to batch all the x,y,scale changes into one frame, -> improve performance
            if (!ticking) {
              requestAnimationFrame(() => {
                if (pendingTransform) {
                  // Apply transform using CSS transform (GPU accelerated)
                  const t = pendingTransform;
                  countriesNode.style.transform = `translate3d(${t.x}px, ${t.y}px, 0) scale(${t.k})`;
                  pendingTransform = null;
                }
                ticking = false;
              });
              ticking = true;
            }
          })
          .on('end', (event) => {
            // Start momentum animation if velocity is significant
            const speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);

            console.log('Zoom end:', {
              eventType: event.sourceEvent?.type,
              velocity: [velocityX.toFixed(2), velocityY.toFixed(2)],
              speed: speed.toFixed(2),
              isPinchZooming
            });

            // Only apply momentum if:
            // 1. Speed is significant
            // 2. This is a touch/mouse end event
            // 3. This was NOT a pinch zoom gesture
            if (speed > 1 && event.sourceEvent && !isPinchZooming) {
              const eventType = event.sourceEvent.type;
              if (eventType === 'touchend' || eventType === 'mouseup') {
                console.log('✅ Starting momentum animation');
                isAnimatingMomentum = false; // Will be set to true in animateMomentum
                animateMomentum();
              } else {
                console.log('❌ Wrong event type for momentum:', eventType);
              }
            } else {
              if (isPinchZooming) {
                console.log('❌ Was pinch zooming, no momentum');
              } else {
                console.log('❌ Speed too low or no sourceEvent');
              }
            }

            // Send transform data to React Native when zoom ends
            window.ReactNativeWebView?.postMessage(JSON.stringify({
              type: 'transform',
              scale: event.transform.k,
              translateX: event.transform.x,
              translateY: event.transform.y
            }));
          });

        svg.call(zoomBehavior);

        // Set initial zoom to fit screen
        svg.call(zoomBehavior.transform, d3.zoomIdentity.scale(initialScale));

        // console.log('Zoom setup complete');
        // console.log('Initial scale:', initialScale);
        // console.log('Viewport:', viewportWidth, 'x', viewportHeight);
        // console.log('Map bounds:', MAP_WIDTH, 'x', MAP_HEIGHT);
        // console.log('Initial scaled size:', MAP_WIDTH * initialScale, 'x', MAP_HEIGHT * initialScale);
      }

      // Handle messages from React Native
      document.addEventListener('message', function(event) {
        const data = JSON.parse(event.data);
        if (data.type === 'zoomToCountry') {
          // Implement zoom to country functionality if needed
        }
      });
    })();
  </script>
</body>
</html>
